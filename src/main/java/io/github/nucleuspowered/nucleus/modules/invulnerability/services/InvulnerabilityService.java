/*
 * This file is part of Nucleus, licensed under the MIT License (MIT). See the LICENSE.txt file
 * at the root of this project for more details.
 */
package io.github.nucleuspowered.nucleus.modules.invulnerability.services;

import io.github.nucleuspowered.nucleus.Nucleus;
import io.github.nucleuspowered.nucleus.api.exceptions.NucleusException;
import io.github.nucleuspowered.nucleus.api.service.NucleusInvulnerabilityService;
import io.github.nucleuspowered.nucleus.dataservices.modular.ModularUserService;
import io.github.nucleuspowered.nucleus.internal.annotations.APIService;
import io.github.nucleuspowered.nucleus.internal.interfaces.ServiceBase;
import io.github.nucleuspowered.nucleus.modules.invulnerability.datamodules.InvulnerabilityUserDataModule;
import org.spongepowered.api.entity.living.player.Player;
import org.spongepowered.api.entity.living.player.User;
import org.spongepowered.api.service.context.Context;
import org.spongepowered.api.service.context.ContextCalculator;
import org.spongepowered.api.service.permission.Subject;
import org.spongepowered.api.text.Text;
import org.spongepowered.api.util.annotation.NonnullByDefault;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;

@APIService(NucleusInvulnerabilityService.class)
@NonnullByDefault
public class InvulnerabilityService implements NucleusInvulnerabilityService, ContextCalculator<Subject>, ServiceBase {

    private final Map<UUID, Boolean> invulnerabilityCache = new HashMap<>();
    private final Context context = new Context(NucleusInvulnerabilityService.INVULNERABLE_CONTEXT, "true");

    @Override
    public void accumulateContexts(Subject calculable, Set<Context> accumulator) {
        if (calculable instanceof Player && isInvulnerable((Player) calculable)) {
            accumulator.add(this.context);
        }
    }

    @Override
    public boolean matches(Context context, Subject calculable) {
        return this.context.equals(context) && calculable instanceof Player && isInvulnerable((Player) calculable);
    }

    @Override
    public boolean isInvulnerable(User user) {
        Optional<Player> op = user.getPlayer();
        if (op.isPresent()) {
            return this.invulnerabilityCache.computeIfAbsent(
                    user.getUniqueId(),
                    uuid -> Nucleus.getNucleus().getUserDataManager().get(user)
                            .map(x -> x.get(InvulnerabilityUserDataModule.class).isInvulnerable()).orElse(false)
            );
        }

        return Nucleus.getNucleus().getUserDataManager().get(user).map(x -> x.get(InvulnerabilityUserDataModule.class).isInvulnerable()).orElse(false);
    }

    @Override
    public void setInvulnerable(User user, boolean invulnerable) throws NucleusException {
        ModularUserService mus = Nucleus.getNucleus().getUserDataManager().get(user)
                .orElseThrow(() -> new NucleusException(
                        Text.of("User does not have a data file available"), NucleusException.ExceptionType.DOES_NOT_EXIST));

        mus.get(InvulnerabilityUserDataModule.class).setInvulnerable(invulnerable);
        user.getPlayer().ifPresent(x -> this.invulnerabilityCache.put(user.getUniqueId(), invulnerable));

        if (!mus.save()) {
            throw new NucleusException(Text.of("Could not save data"), NucleusException.ExceptionType.UNKNOWN_ERROR);
        }
    }

    public void removeFromCache(UUID uuid) {
        this.invulnerabilityCache.remove(uuid);
    }
}
